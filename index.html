<!DOCTYPE html>
<html lang="en">
<head>
  <!--
    MIT License

    Copyright (c) 2025 NQR

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
  -->
  <!-- Favicons (browser tabs, bookmarks) -->
  <link rel="icon" type="image/png" sizes="32x32" href="assets/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="assets/images/favicon-16x16.png">
    
  <!-- iOS & iPadOS (home screen icon when ï¿½Add to Home Screenï¿½) -->
  <link rel="apple-touch-icon" sizes="180x180" href="assets/images/apple-touch-icon-180x180.png">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Apoculus</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #04070a;
      color: #d7e8ff;
      overflow: hidden;
      height: 100vh;
    }

    .container {
      display: flex;
      height: 100vh;
    }

    /* Control Panel */
    .control-panel {
      width: 320px;
      background: linear-gradient(180deg, #0a0f14 0%, #04070a 100%);
      border-right: 1px solid rgba(93, 225, 255, 0.2);
      overflow-y: auto;
      overflow-x: hidden;
      padding: 20px;
    }

    .control-panel::-webkit-scrollbar {
      width: 8px;
    }

    .control-panel::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.2);
    }

    .control-panel::-webkit-scrollbar-thumb {
      background: rgba(93, 225, 255, 0.3);
      border-radius: 4px;
    }

    .control-panel::-webkit-scrollbar-thumb:hover {
      background: rgba(93, 225, 255, 0.5);
    }

    header {
      margin-bottom: 20px;
      padding-bottom: 15px;
      border-bottom: 2px solid rgba(93, 225, 255, 0.2);
    }

    h1 {
      font-size: 1.8rem;
      color: #5de1ff;
      margin-bottom: 5px;
      text-shadow: 0 0 10px rgba(93, 225, 255, 0.3);
      justify-content: center;
      align-items: center;
      display: flex;
    }

    .subtitle {
      font-size: 0.85rem;
      color: #97f3d2;
      opacity: 0.9;
      justify-content: center;
      align-items: center;
      display: flex;
    }

    .section {
      margin-bottom: 25px;
    }

    .section-title {
      font-size: 0.9rem;
      color: #00d4ff;
      margin-bottom: 12px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      font-weight: bold;
    }

    .control-group {
      margin-bottom: 15px;
    }

    .control-label {
      display: block;
      font-size: 0.85rem;
      color: #97f3d2;
      margin-bottom: 6px;
    }

    input[type="text"],
    input[type="number"],
    select,
    textarea {
      width: 100%;
      padding: 8px 10px;
      background: rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(93, 225, 255, 0.3);
      border-radius: 4px;
      color: #d7e8ff;
      font-size: 0.9rem;
      font-family: inherit;
    }

    textarea {
      resize: vertical;
      min-height: 60px;
      font-family: 'Segoe UI', sans-serif;
    }

    input[type="text"]:focus,
    input[type="number"]:focus,
    select:focus,
    textarea:focus {
      outline: none;
      border-color: #5de1ff;
      box-shadow: 0 0 8px rgba(93, 225, 255, 0.3);
    }

    input[type="range"] {
      width: 100%;
      height: 4px;
      background: rgba(93, 225, 255, 0.2);
      border-radius: 2px;
      outline: none;
      -webkit-appearance: none;
      appearance: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      background: #5de1ff;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 0 8px rgba(93, 225, 255, 0.5);
    }

    input[type="range"]::-moz-range-thumb {
      width: 16px;
      height: 16px;
      background: #5de1ff;
      border-radius: 50%;
      cursor: pointer;
      border: none;
      box-shadow: 0 0 8px rgba(93, 225, 255, 0.5);
    }

    .range-value {
      display: inline-block;
      margin-left: 10px;
      font-size: 0.85rem;
      color: #5de1ff;
      min-width: 50px;
      text-align: right;
    }

    .range-container {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .range-container input[type="range"] {
      flex: 1;
    }

    button {
      padding: 10px 16px;
      background: linear-gradient(135deg, #5de1ff 0%, #00ffaa 100%);
      border: none;
      border-radius: 4px;
      color: #04070a;
      font-size: 0.9rem;
      font-weight: bold;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
      box-shadow: 0 4px 12px rgba(93, 225, 255, 0.3);
      width: 100%;
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(93, 225, 255, 0.5);
    }

    button:active {
      transform: translateY(0);
    }

    .button-group {
      display: flex;
      gap: 8px;
      margin-bottom: 10px;
    }

    .button-group button {
      flex: 1;
    }

    .secondary-btn {
      background: linear-gradient(135deg, rgba(93, 225, 255, 0.2) 0%, rgba(0, 255, 170, 0.2) 100%);
      color: #5de1ff;
    }

    .danger-btn {
      background: linear-gradient(135deg, rgba(255, 93, 93, 0.3) 0%, rgba(255, 0, 85, 0.3) 100%);
      color: #ff5d5d;
    }

    input[type="file"] {
      display: none;
    }

    .file-label {
      display: block;
      padding: 10px 16px;
      background: linear-gradient(135deg, rgba(93, 225, 255, 0.2) 0%, rgba(0, 255, 170, 0.2) 100%);
      border: 1px solid rgba(93, 225, 255, 0.3);
      border-radius: 4px;
      color: #5de1ff;
      font-size: 0.9rem;
      font-weight: bold;
      cursor: pointer;
      text-align: center;
      transition: all 0.2s;
    }

    .file-label:hover {
      background: linear-gradient(135deg, rgba(93, 225, 255, 0.3) 0%, rgba(0, 255, 170, 0.3) 100%);
      border-color: #5de1ff;
    }

    .info-hint {
      font-size: 0.75rem;
      color: rgba(151, 243, 210, 0.7);
      margin-top: 4px;
    }

    /* Layers */
    .layer-list {
      max-height: 300px;
      overflow-y: auto;
      margin-bottom: 10px;
      border: 1px solid rgba(93, 225, 255, 0.2);
      border-radius: 4px;
      background: rgba(0, 0, 0, 0.2);
    }

    .layer-item {
      padding: 10px;
      border-bottom: 1px solid rgba(93, 225, 255, 0.1);
      cursor: pointer;
      transition: background 0.2s;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .layer-item:hover {
      background: rgba(93, 225, 255, 0.05);
    }

    .layer-item.active {
      background: rgba(93, 225, 255, 0.15);
      border-left: 3px solid #5de1ff;
    }

    .layer-info {
      width: 100%;
    }

    .layer-name {
      font-size: 0.9rem;
      color: #d7e8ff;
      font-weight: bold;
      margin-bottom: 2px;
    }

    .layer-details {
      font-size: 0.75rem;
      color: rgba(151, 243, 210, 0.7);
    }

    .layer-delete {
      width: 100%;
      padding: 6px 10px;
      background: rgba(255, 93, 93, 0.2);
      border: 1px solid rgba(255, 93, 93, 0.3);
      border-radius: 3px;
      color: #ff5d5d;
      font-size: 0.8rem;
      cursor: pointer;
      transition: all 0.2s;
      text-align: center;
    }

    .layer-delete:hover {
      background: rgba(255, 93, 93, 0.3);
    }

    /* Preview Panel */
    .preview-panel {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: #04070a;
      position: relative;
    }

    .preview-header {
      padding: 15px 20px;
      background: rgba(10, 15, 20, 0.8);
      border-bottom: 1px solid rgba(93, 225, 255, 0.2);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .preview-title {
      font-size: 1.1rem;
      color: #5de1ff;
    }

    .preview-actions {
      display: flex;
      gap: 10px;
    }

    .preview-actions button {
      width: auto;
      padding: 8px 16px;
    }

    .preview-container {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
      overflow: auto;
    }

    #previewCanvas {
      max-width: 100%;
      max-height: 100%;
      border: 1px solid rgba(93, 225, 255, 0.3);
      box-shadow: 0 0 20px rgba(93, 225, 255, 0.2);
      background: #000;
    }

    .help-text {
      text-align: center;
      color: rgba(151, 243, 210, 0.5);
      font-size: 0.9rem;
      padding: 20px;
    }

    @media (max-width: 768px) {
      .container {
        flex-direction: column;
      }

      .control-panel {
        width: 100%;
        height: 50vh;
        border-right: none;
        border-bottom: 1px solid rgba(93, 225, 255, 0.2);
      }

      .preview-panel {
        height: 50vh;
      }
    }

    /* License modal styles */
    .license-footer {
      margin-top: 30px;
      margin-bottom: 20px;
      padding: 10px 8px;
      font-size: 0.68rem;
      color: #a9a9b2;
      opacity: 0.7;
      cursor: pointer;
      transition: opacity 0.15s ease;
      text-align: center;
    }

    .license-footer:hover { opacity: 1; }

    .license-overlay {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.7);
      z-index: 999;
    }

    .license-modal {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #0f0f16;
      border: 2px solid rgba(93, 225, 255, 0.35);
      border-radius: 12px;
      padding: 20px;
      max-width: 520px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 20px 60px rgba(0,0,0,.6);
      z-index: 1000;
      text-align: center;
    }

    .license-modal.show,
    .license-overlay.show {
      display: block;
    }

    .license-modal-header {
      position: relative;
      display: flex;
      justify-content: center;
      align-items: center;
      padding-right: 32px;
      gap: 12px;
    }

    .license-modal-title {
      font-size: 18px;
      color: #5de1ff;
      margin-bottom: 15px;
    }

    .license-modal-text {
      font-size: 12px;
      line-height: 1.6;
      color: #b0b0b0;
      text-align: left;
      white-space: pre-wrap;
    }

    .license-close {
      position: absolute;
      top: 0;
      right: 0;
      width: 28px;
      height: 28px;
      border-radius: 50%;
      background: rgba(255,0,0,0.15);
      border: 1px solid rgba(255,0,0,0.3);
      color: #ff5555;
      font-size: 18px;
      line-height: 1;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .license-close:hover {
      background: rgba(255,0,0,0.3);
      border-color: #ff5555;
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- Control Panel -->
    <div class="control-panel">
      <header>
        <img src="assets/images/logo.png" alt="Apoculus Logo" onerror="this.style.display='none'" style="display:block; margin-left:auto; margin-right:auto; width:50%;">
        <h1>Apoculus</h1>
        <p class="subtitle">3D Image Generator</p>
      </header>

      <!-- Add Layer -->
      <div class="section">
        <div class="section-title">Add Layer</div>
        <div class="button-group">
          <button id="addTextBtn">+ Text</button>
          <button id="addImageBtn" class="secondary-btn">+ Image</button>
        </div>
        <input type="file" id="imageFileInput" accept="image/*">
      </div>

      <!-- Layers -->
      <div class="section">
        <div class="section-title">Layers</div>
        <div class="layer-list" id="layerList">
          <div class="help-text" style="font-size: 0.85rem; padding: 15px;">
            No layers yet. Add text or an image to begin.
          </div>
        </div>
      </div>

      <!-- Layer Settings -->
      <div class="section" id="layerSettings" style="display: none;">
        <div class="section-title">Layer Settings</div>

        <!-- Text Content -->
        <div class="control-group" id="textContentGroup" style="display: none;">
          <label class="control-label">Text</label>
          <textarea id="layerText" placeholder="Enter text..."></textarea>
        </div>

        <!-- Font Selection -->
        <div class="control-group" id="fontGroup" style="display: none;">
          <label class="control-label">Font</label>
          <select id="layerFont">
            <option value="'Arial Black', sans-serif">Arial Black</option>
            <option value="'Impact', sans-serif">Impact</option>
            <option value="'Trebuchet MS', sans-serif">Trebuchet MS</option>
            <option value="'Verdana', sans-serif">Verdana</option>
            <option value="'Tahoma', sans-serif">Tahoma</option>
            <option value="custom">Upload Custom Font...</option>
          </select>
          <input type="file" id="customFontInput" accept=".ttf,.otf,.woff,.woff2" style="margin-top: 8px;">
        </div>

        <!-- Size -->
        <div class="control-group">
          <label class="control-label">Size</label>
          <div class="range-container">
            <input type="range" id="layerSize" min="20" max="400" value="100">
            <span class="range-value" id="layerSizeValue">100</span>
          </div>
        </div>

        <!-- Depth -->
        <div class="control-group">
          <label class="control-label">Depth Level</label>
          <div class="range-container">
            <input type="range" id="layerDepth" min="0" max="100" value="20">
            <span class="range-value" id="layerDepthValue">20</span>
          </div>
          <div class="info-hint">Higher = closer to you</div>
        </div>

        <!-- Rotation -->
        <div class="control-group">
          <label class="control-label">Rotation</label>
          <div class="range-container">
            <input type="range" id="layerRotation" min="-180" max="180" value="0">
            <span class="range-value" id="layerRotationValue">0Â°</span>
          </div>
        </div>

        <!-- Position X -->
        <div class="control-group">
          <label class="control-label">Horizontal Position</label>
          <div class="range-container">
            <input type="range" id="layerX" min="0" max="1000" value="500">
            <span class="range-value" id="layerXValue">500</span>
          </div>
        </div>

        <!-- Position Y -->
        <div class="control-group">
          <label class="control-label">Vertical Position</label>
          <div class="range-container">
            <input type="range" id="layerY" min="0" max="1000" value="500">
            <span class="range-value" id="layerYValue">500</span>
          </div>
        </div>

        <!-- Invert Alpha (for images) -->
        <div class="control-group" id="invertAlphaGroup" style="display: none;">
          <label class="control-label">
            <input type="checkbox" id="invertAlpha" style="width: auto; margin-right: 8px;">
            Invert Alpha Channel
          </label>
          <div class="info-hint">When checked, black becomes transparent instead of white</div>
        </div>
      </div>

      <!-- Global Settings -->
      <div class="section">
        <div class="section-title">Image Settings</div>

        <!-- Pattern Density -->
        <div class="control-group">
          <label class="control-label">Pattern Density</label>
          <div class="range-container">
            <input type="range" id="patternDensity" min="2" max="8" value="4" step="1">
            <span class="range-value" id="patternDensityValue">4</span>
          </div>
          <div class="info-hint">Dots per tile</div>
        </div>

        <!-- Strip Width -->
        <div class="control-group">
          <label class="control-label">Pattern Width</label>
          <div class="range-container">
            <input type="range" id="stripWidth" min="48" max="96" value="72" step="4">
            <span class="range-value" id="stripWidthValue">72px</span>
          </div>
        </div>

        <!-- Depth Scale -->
        <div class="control-group">
          <label class="control-label">3D Effect Strength</label>
          <div class="range-container">
            <input type="range" id="depthScale" min="0.3" max="1.5" value="0.8" step="0.1">
            <span class="range-value" id="depthScaleValue">0.8</span>
          </div>
        </div>

        <!-- Output Size -->
        <div class="control-group">
          <label class="control-label">Output Width</label>
          <div class="range-container">
            <input type="range" id="outputWidth" min="800" max="2000" value="1200" step="100">
            <span class="range-value" id="outputWidthValue">1200px</span>
          </div>
        </div>

        <!-- Color Scheme -->
        <div class="control-group">
          <label class="control-label">Color Scheme</label>
          <select id="colorScheme">
            <option value="grayscale">Grayscale</option>
            <option value="color">Random Colors</option>
            <option value="cyan">Cyan Dots</option>
            <option value="magenta">Magenta Dots</option>
            <option value="green">Green Dots</option>
            <option value="amber">Amber Dots</option>
            <option value="rainbow">Rainbow</option>
            <option value="neon">Neon Mix</option>
            <option value="fire">Fire</option>
            <option value="ice">Ice</option>
            <option value="forest">Forest</option>
            <option value="sunset">Sunset</option>
            <option value="ocean">Ocean</option>
            <option value="matrix">Matrix Green</option>
            <option value="vaporwave">Vaporwave</option>
            <option value="synthwave">Synthwave</option>
          </select>
        </div>
      </div>

      <!-- Export -->
      <div class="section">
        <button id="downloadBtn">â¬‡ Download Image</button>
      </div>

      <div class="license-footer" id="licenseFooter">
        MIT License Â© 2025 NQR &middot; Click to view
      </div>
    </div>

    <!-- Preview Panel -->
    <div class="preview-panel">
      <div class="preview-header">
        <div class="preview-title">Preview</div>
        <div class="preview-actions">
          <button id="regenerateBtn">ðŸ”„ Regenerate</button>
        </div>
      </div>
      <div class="preview-container">
        <canvas id="previewCanvas" width="1200" height="800"></canvas>
      </div>
    </div>
  </div>

  <!-- License Modal -->
  <div class="license-overlay" id="licenseOverlay"></div>
  <div class="license-modal" id="licenseModal">
    <div class="license-modal-header">
      <h2 class="license-modal-title">MIT License</h2>
      <div class="license-close" id="licenseClose">Ã—</div>
    </div>
    <div class="license-modal-text">Copyright (c) 2025 NQR

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    </div>
  </div>

  <script>
    // App State
    const state = {
      layers: [],
      activeLayerId: null,
      customFonts: new Map(),
      settings: {
        patternDensity: 4,
        stripWidth: 72,
        depthScale: 0.8,
        outputWidth: 1200,
        outputHeight: 800,
        colorScheme: 'grayscale'
      }
    };

    let nextLayerId = 1;

    // DOM Elements
    const previewCanvas = document.getElementById('previewCanvas');
    const ctx = previewCanvas.getContext('2d', { willReadFrequently: true });
    const layerList = document.getElementById('layerList');
    const layerSettings = document.getElementById('layerSettings');

    // Layer management
    const addTextBtn = document.getElementById('addTextBtn');
    const addImageBtn = document.getElementById('addImageBtn');
    const imageFileInput = document.getElementById('imageFileInput');

    // Layer controls
    const textContentGroup = document.getElementById('textContentGroup');
    const fontGroup = document.getElementById('fontGroup');
    const layerText = document.getElementById('layerText');
    const layerFont = document.getElementById('layerFont');
    const customFontInput = document.getElementById('customFontInput');
    const layerSize = document.getElementById('layerSize');
    const layerDepth = document.getElementById('layerDepth');
    const layerRotation = document.getElementById('layerRotation');
    const layerX = document.getElementById('layerX');
    const layerY = document.getElementById('layerY');
    const invertAlphaGroup = document.getElementById('invertAlphaGroup');
    const invertAlpha = document.getElementById('invertAlpha');

    // Global controls
    const patternDensity = document.getElementById('patternDensity');
    const stripWidth = document.getElementById('stripWidth');
    const depthScale = document.getElementById('depthScale');
    const outputWidth = document.getElementById('outputWidth');
    const colorScheme = document.getElementById('colorScheme');

    // Actions
    const regenerateBtn = document.getElementById('regenerateBtn');
    const downloadBtn = document.getElementById('downloadBtn');

    // Add Text Layer
    addTextBtn.addEventListener('click', () => {
      const layer = {
        id: nextLayerId++,
        type: 'text',
        text: 'Your Text Here',
        font: "'Arial Black', sans-serif",
        size: 100,
        depth: 20,
        rotation: 0,
        x: state.settings.outputWidth / 2,
        y: state.settings.outputHeight / 2
      };
      state.layers.push(layer);
      updateLayerList();
      selectLayer(layer.id);
      generateAutostereogram();
    });

    // Process image: grayscale â†’ dither â†’ alpha
    function processImageToAlpha(img, invertAlpha = false) {
      const canvas = document.createElement('canvas');
      canvas.width = img.width;
      canvas.height = img.height;
      const ctx = canvas.getContext('2d');

      // Draw original image
      ctx.drawImage(img, 0, 0);
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;

      // Check if image has meaningful alpha channel
      let hasAlpha = false;
      for (let i = 3; i < data.length; i += 4) {
        if (data[i] < 255) {
          hasAlpha = true;
          break;
        }
      }

      // If already has alpha, return as-is
      if (hasAlpha) {
        return img;
      }

      // Convert to grayscale
      const grayData = new Uint8ClampedArray(canvas.width * canvas.height);
      for (let i = 0; i < data.length; i += 4) {
        const gray = Math.floor(0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2]);
        grayData[i / 4] = gray;
      }

      // Floyd-Steinberg dithering
      const ditherData = new Uint8ClampedArray(grayData);
      for (let y = 0; y < canvas.height; y++) {
        for (let x = 0; x < canvas.width; x++) {
          const idx = y * canvas.width + x;
          const oldPixel = ditherData[idx];
          const newPixel = oldPixel < 128 ? 0 : 255;
          ditherData[idx] = newPixel;

          const error = oldPixel - newPixel;

          // Distribute error to neighbors
          if (x + 1 < canvas.width) {
            ditherData[idx + 1] += error * 7 / 16;
          }
          if (y + 1 < canvas.height) {
            if (x > 0) {
              ditherData[idx + canvas.width - 1] += error * 3 / 16;
            }
            ditherData[idx + canvas.width] += error * 5 / 16;
            if (x + 1 < canvas.width) {
              ditherData[idx + canvas.width + 1] += error * 1 / 16;
            }
          }
        }
      }

      // Convert to RGBA with alpha channel
      // White â†’ transparent (or black if inverted)
      for (let i = 0; i < ditherData.length; i++) {
        const isWhite = ditherData[i] === 255;
        const shouldBeTransparent = invertAlpha ? !isWhite : isWhite;

        data[i * 4] = 255;
        data[i * 4 + 1] = 255;
        data[i * 4 + 2] = 255;
        data[i * 4 + 3] = shouldBeTransparent ? 0 : 255;
      }

      ctx.putImageData(imageData, 0, 0);

      // Convert canvas to image
      const processedImg = new Image();
      processedImg.src = canvas.toDataURL();
      return processedImg;
    }

    // Add Image Layer
    addImageBtn.addEventListener('click', () => {
      imageFileInput.click();
    });

    imageFileInput.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;

      const img = new Image();
      img.onload = () => {
        const layer = {
          id: nextLayerId++,
          type: 'image',
          originalImage: img,
          image: img, // Will be processed
          size: 50, // Multiplied by 4 internally = 200px actual
          depth: 20,
          rotation: 0,
          x: state.settings.outputWidth / 2,
          y: state.settings.outputHeight / 2,
          invertAlpha: false
        };

        // Process the image
        layer.image = processImageToAlpha(img, layer.invertAlpha);

        state.layers.push(layer);
        updateLayerList();
        selectLayer(layer.id);

        // Wait for processed image to load before generating
        if (layer.image !== img) {
          layer.image.onload = () => generateAutostereogram();
        } else {
          generateAutostereogram();
        }
      };
      img.src = URL.createObjectURL(file);
      imageFileInput.value = '';
    });

    // Custom Font Upload
    customFontInput.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;

      const fontName = 'CustomFont_' + Date.now();
      const arrayBuffer = await file.arrayBuffer();
      const fontFace = new FontFace(fontName, arrayBuffer);
      await fontFace.load();
      document.fonts.add(fontFace);

      state.customFonts.set(fontName, fontName);

      const activeLayer = getActiveLayer();
      if (activeLayer && activeLayer.type === 'text') {
        activeLayer.font = fontName;
        generateAutostereogram();
      }

      customFontInput.value = '';
    });

    layerFont.addEventListener('change', (e) => {
      if (e.target.value === 'custom') {
        customFontInput.click();
      } else {
        const activeLayer = getActiveLayer();
        if (activeLayer && activeLayer.type === 'text') {
          activeLayer.font = e.target.value;
          generateAutostereogram();
        }
      }
    });

    // Layer Settings Event Listeners
    layerText.addEventListener('input', () => {
      const activeLayer = getActiveLayer();
      if (activeLayer && activeLayer.type === 'text') {
        activeLayer.text = layerText.value;
        updateLayerList();
        generateAutostereogram();
      }
    });

    layerSize.addEventListener('input', (e) => {
      const activeLayer = getActiveLayer();
      if (activeLayer) {
        activeLayer.size = parseInt(e.target.value);
        document.getElementById('layerSizeValue').textContent = e.target.value;

        // Reprocess image if it's an image layer
        if (activeLayer.type === 'image' && activeLayer.originalImage) {
          activeLayer.image = processImageToAlpha(activeLayer.originalImage, activeLayer.invertAlpha);
          if (activeLayer.image !== activeLayer.originalImage) {
            activeLayer.image.onload = () => generateAutostereogram();
          } else {
            generateAutostereogram();
          }
        } else {
          generateAutostereogram();
        }
      }
    });

    invertAlpha.addEventListener('change', (e) => {
      const activeLayer = getActiveLayer();
      if (activeLayer && activeLayer.type === 'image') {
        activeLayer.invertAlpha = e.target.checked;

        // Reprocess the image
        if (activeLayer.originalImage) {
          activeLayer.image = processImageToAlpha(activeLayer.originalImage, activeLayer.invertAlpha);
          if (activeLayer.image !== activeLayer.originalImage) {
            activeLayer.image.onload = () => generateAutostereogram();
          } else {
            generateAutostereogram();
          }
        }
      }
    });

    layerDepth.addEventListener('input', (e) => {
      const activeLayer = getActiveLayer();
      if (activeLayer) {
        activeLayer.depth = parseInt(e.target.value);
        document.getElementById('layerDepthValue').textContent = e.target.value;
        generateAutostereogram();
      }
    });

    layerRotation.addEventListener('input', (e) => {
      const activeLayer = getActiveLayer();
      if (activeLayer) {
        activeLayer.rotation = parseInt(e.target.value);
        document.getElementById('layerRotationValue').textContent = e.target.value + 'Â°';
        generateAutostereogram();
      }
    });

    layerX.addEventListener('input', (e) => {
      const activeLayer = getActiveLayer();
      if (activeLayer) {
        activeLayer.x = parseInt(e.target.value);
        document.getElementById('layerXValue').textContent = e.target.value;
        generateAutostereogram();
      }
    });

    layerY.addEventListener('input', (e) => {
      const activeLayer = getActiveLayer();
      if (activeLayer) {
        activeLayer.y = parseInt(e.target.value);
        document.getElementById('layerYValue').textContent = e.target.value;
        generateAutostereogram();
      }
    });

    // Global Settings Event Listeners
    patternDensity.addEventListener('input', (e) => {
      state.settings.patternDensity = parseInt(e.target.value);
      document.getElementById('patternDensityValue').textContent = e.target.value;
      generateAutostereogram();
    });

    stripWidth.addEventListener('input', (e) => {
      state.settings.stripWidth = parseInt(e.target.value);
      document.getElementById('stripWidthValue').textContent = e.target.value + 'px';
      generateAutostereogram();
    });

    depthScale.addEventListener('input', (e) => {
      state.settings.depthScale = parseFloat(e.target.value);
      document.getElementById('depthScaleValue').textContent = e.target.value;
      generateAutostereogram();
    });

    outputWidth.addEventListener('input', (e) => {
      state.settings.outputWidth = parseInt(e.target.value);
      state.settings.outputHeight = Math.round(state.settings.outputWidth * 2 / 3);
      document.getElementById('outputWidthValue').textContent = e.target.value + 'px';

      previewCanvas.width = state.settings.outputWidth;
      previewCanvas.height = state.settings.outputHeight;

      // Update position sliders max values
      layerX.max = state.settings.outputWidth;
      layerY.max = state.settings.outputHeight;

      generateAutostereogram();
    });

    colorScheme.addEventListener('change', (e) => {
      state.settings.colorScheme = e.target.value;
      generateAutostereogram();
    });

    regenerateBtn.addEventListener('click', () => {
      generateAutostereogram();
    });

    downloadBtn.addEventListener('click', () => {
      const link = document.createElement('a');
      link.download = 'apoculus-3d-image.png';
      link.href = previewCanvas.toDataURL();
      link.click();
    });

    // License modal
    document.getElementById('licenseFooter').addEventListener('click', () => {
      document.getElementById('licenseModal').classList.add('show');
      document.getElementById('licenseOverlay').classList.add('show');
    });

    const closeLicense = () => {
      document.getElementById('licenseModal').classList.remove('show');
      document.getElementById('licenseOverlay').classList.remove('show');
    };

    document.getElementById('licenseClose').addEventListener('click', closeLicense);
    document.getElementById('licenseOverlay').addEventListener('click', closeLicense);

    // Helper Functions
    function getActiveLayer() {
      return state.layers.find(l => l.id === state.activeLayerId);
    }

    function selectLayer(id) {
      state.activeLayerId = id;
      const layer = getActiveLayer();

      if (!layer) {
        layerSettings.style.display = 'none';
        return;
      }

      layerSettings.style.display = 'block';

      // Show/hide appropriate controls
      if (layer.type === 'text') {
        textContentGroup.style.display = 'block';
        fontGroup.style.display = 'block';
        invertAlphaGroup.style.display = 'none';
        layerText.value = layer.text;
        layerFont.value = layer.font;
      } else {
        textContentGroup.style.display = 'none';
        fontGroup.style.display = 'none';
        invertAlphaGroup.style.display = 'block';
        invertAlpha.checked = layer.invertAlpha || false;
      }

      // Update controls
      layerSize.value = layer.size;
      layerDepth.value = layer.depth;
      layerRotation.value = layer.rotation;
      layerX.value = layer.x;
      layerY.value = layer.y;

      document.getElementById('layerSizeValue').textContent = layer.size;
      document.getElementById('layerDepthValue').textContent = layer.depth;
      document.getElementById('layerRotationValue').textContent = layer.rotation + 'Â°';
      document.getElementById('layerXValue').textContent = layer.x;
      document.getElementById('layerYValue').textContent = layer.y;

      updateLayerList();
    }

    function deleteLayer(id) {
      const index = state.layers.findIndex(l => l.id === id);
      if (index !== -1) {
        state.layers.splice(index, 1);
        if (state.activeLayerId === id) {
          state.activeLayerId = state.layers.length > 0 ? state.layers[0].id : null;
        }
        updateLayerList();
        if (state.activeLayerId) {
          selectLayer(state.activeLayerId);
        } else {
          layerSettings.style.display = 'none';
        }
        generateAutostereogram();
      }
    }

    function updateLayerList() {
      if (state.layers.length === 0) {
        layerList.innerHTML = `
          <div class="help-text" style="font-size: 0.85rem; padding: 15px;">
            No layers yet. Add text or an image to begin.
          </div>
        `;
        return;
      }

      layerList.innerHTML = state.layers.map(layer => {
        const isActive = layer.id === state.activeLayerId;
        const name = layer.type === 'text'
          ? (layer.text.substring(0, 20) + (layer.text.length > 20 ? '...' : ''))
          : 'Image';
        const details = `Depth: ${layer.depth} | Size: ${layer.size}`;

        return `
          <div class="layer-item ${isActive ? 'active' : ''}" data-id="${layer.id}">
            <div class="layer-info">
              <div class="layer-name">${name}</div>
              <div class="layer-details">${details}</div>
            </div>
            <button class="layer-delete" data-id="${layer.id}">Delete</button>
          </div>
        `;
      }).join('');

      // Add event listeners
      layerList.querySelectorAll('.layer-item').forEach(item => {
        item.addEventListener('click', (e) => {
          if (!e.target.classList.contains('layer-delete')) {
            selectLayer(parseInt(item.dataset.id));
          }
        });
      });

      layerList.querySelectorAll('.layer-delete').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          deleteLayer(parseInt(btn.dataset.id));
        });
      });
    }

    // Generate Depth Map from Layers
    function generateDepthMap() {
      const width = state.settings.outputWidth;
      const height = state.settings.outputHeight;

      // Create temporary canvas for depth map
      const depthCanvas = document.createElement('canvas');
      depthCanvas.width = width;
      depthCanvas.height = height;
      const depthCtx = depthCanvas.getContext('2d');

      // Fill with background depth (0 = farthest)
      depthCtx.fillStyle = '#000000';
      depthCtx.fillRect(0, 0, width, height);

      // Render each layer sorted by depth (farthest first)
      const sortedLayers = [...state.layers].sort((a, b) => a.depth - b.depth);

      sortedLayers.forEach(layer => {
        depthCtx.save();
        depthCtx.translate(layer.x, layer.y);
        depthCtx.rotate((layer.rotation * Math.PI) / 180);

        // Calculate depth color (0-255 based on depth 0-100)
        const depthColor = Math.floor((layer.depth / 100) * 255);
        depthCtx.fillStyle = `rgb(${depthColor}, ${depthColor}, ${depthColor})`;

        if (layer.type === 'text') {
          depthCtx.font = `bold ${layer.size}px ${layer.font}`;
          depthCtx.textAlign = 'center';
          depthCtx.textBaseline = 'middle';
          depthCtx.fillText(layer.text, 0, 0);
        } else if (layer.type === 'image') {
          const aspectRatio = layer.image.width / layer.image.height;
          // Scale images 4x larger for better visibility
          const scaledSize = layer.size * 4;
          const drawWidth = scaledSize * aspectRatio;
          const drawHeight = scaledSize;

          // Draw image as grayscale at depth level
          depthCtx.globalCompositeOperation = 'source-over';
          const tempCanvas = document.createElement('canvas');
          tempCanvas.width = drawWidth;
          tempCanvas.height = drawHeight;
          const tempCtx = tempCanvas.getContext('2d');
          tempCtx.drawImage(layer.image, 0, 0, drawWidth, drawHeight);

          // Convert to single color at depth level (use alpha from image)
          const imgData = tempCtx.getImageData(0, 0, drawWidth, drawHeight);
          for (let i = 0; i < imgData.data.length; i += 4) {
            const alpha = imgData.data[i + 3];
            imgData.data[i] = depthColor;
            imgData.data[i + 1] = depthColor;
            imgData.data[i + 2] = depthColor;
          }
          tempCtx.putImageData(imgData, 0, 0);

          depthCtx.drawImage(tempCanvas, -drawWidth / 2, -drawHeight / 2);
        }

        depthCtx.restore();
      });

      // Apply blur for soft edges (reduce sparkle)
      depthCtx.filter = 'blur(2px)';
      depthCtx.drawImage(depthCanvas, 0, 0);
      depthCtx.filter = 'none';

      // Get depth map data
      const imageData = depthCtx.getImageData(0, 0, width, height);
      const depthMap = new Uint8Array(width * height);

      for (let i = 0; i < depthMap.length; i++) {
        depthMap[i] = imageData.data[i * 4]; // Use red channel
      }

      return depthMap;
    }

    // Simple hash function for pseudo-random per-pixel values
    function hashPixel(x, y, seed) {
      let h = seed + x * 374761393 + y * 668265263;
      h = (h ^ (h >>> 13)) * 1274126177;
      return (h ^ (h >>> 16)) >>> 0;
    }

    // Convert hash to [0,1) float
    function hashToFloat(hash) {
      return (hash & 0xFFFFFF) / 0x1000000;
    }

    // Generate Random Dot Pattern Strip
    function generatePatternStrip(width, height, density, colorScheme) {
      const stripCanvas = document.createElement('canvas');
      stripCanvas.width = width;
      stripCanvas.height = height;
      const stripCtx = stripCanvas.getContext('2d');

      const imageData = stripCtx.createImageData(width, height);
      const data = imageData.data;

      // Random seed for this generation
      const seed = Math.floor(Math.random() * 0xFFFFFFFF);

      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const i = (y * width + x) * 4;

          // Use hash-based random for better distribution
          const hash1 = hashPixel(x, y, seed);
          const hash2 = hashPixel(x, y, seed + 1);
          const hash3 = hashPixel(x, y, seed + 2);

          const rand1 = hashToFloat(hash1);
          const rand2 = hashToFloat(hash2);
          const rand3 = hashToFloat(hash3);

          // Determine if this pixel is "on" (higher density = more dots)
          const threshold = density / 10;
          const isOn = rand1 < threshold;

          let r, g, b;

          if (colorScheme === 'grayscale') {
            const brightness = isOn ? Math.floor(rand2 * 255) : 0;
            r = g = b = brightness;
          } else if (colorScheme === 'color') {
            r = isOn ? Math.floor(rand1 * 255) : 0;
            g = isOn ? Math.floor(rand2 * 255) : 0;
            b = isOn ? Math.floor(rand3 * 255) : 0;
          } else if (colorScheme === 'cyan') {
            const brightness = isOn ? Math.floor(rand2 * 255) : 0;
            r = 0;
            g = brightness;
            b = brightness;
          } else if (colorScheme === 'magenta') {
            const brightness = isOn ? Math.floor(rand2 * 255) : 0;
            r = brightness;
            g = 0;
            b = brightness;
          } else if (colorScheme === 'green') {
            const brightness = isOn ? Math.floor(rand2 * 255) : 0;
            r = 0;
            g = brightness;
            b = 0;
          } else if (colorScheme === 'amber') {
            const brightness = isOn ? Math.floor(rand2 * 255) : 0;
            r = brightness;
            g = Math.floor(brightness * 0.75);
            b = 0;
          } else if (colorScheme === 'rainbow') {
            if (isOn) {
              const hue = rand2 * 360;
              const sat = 0.8;
              const light = 0.5;
              const rgb = hslToRgb(hue, sat, light);
              r = rgb[0];
              g = rgb[1];
              b = rgb[2];
            } else {
              r = g = b = 0;
            }
          } else if (colorScheme === 'neon') {
            if (isOn) {
              const choice = Math.floor(rand2 * 5);
              if (choice === 0) { r = 255; g = 0; b = 255; } // Magenta
              else if (choice === 1) { r = 0; g = 255; b = 255; } // Cyan
              else if (choice === 2) { r = 255; g = 255; b = 0; } // Yellow
              else if (choice === 3) { r = 0; g = 255; b = 0; } // Green
              else { r = 255; g = 0; b = 128; } // Hot pink
            } else {
              r = g = b = 0;
            }
          } else if (colorScheme === 'fire') {
            if (isOn) {
              const intensity = rand2;
              r = 255;
              g = Math.floor(intensity * 165); // 0-165
              b = Math.floor(intensity * intensity * 100); // 0-100
            } else {
              r = g = b = 0;
            }
          } else if (colorScheme === 'ice') {
            if (isOn) {
              const intensity = rand2;
              r = Math.floor(intensity * 200 + 55); // 55-255
              g = Math.floor(intensity * 255); // 0-255
              b = 255;
            } else {
              r = g = b = 0;
            }
          } else if (colorScheme === 'forest') {
            if (isOn) {
              const intensity = rand2;
              r = Math.floor(intensity * 100); // 0-100
              g = Math.floor(intensity * 180 + 75); // 75-255
              b = Math.floor(intensity * 80); // 0-80
            } else {
              r = g = b = 0;
            }
          } else if (colorScheme === 'sunset') {
            if (isOn) {
              const choice = rand2;
              if (choice < 0.33) {
                r = 255; g = Math.floor(rand3 * 100); b = Math.floor(rand3 * 150 + 100); // Purple
              } else if (choice < 0.66) {
                r = 255; g = Math.floor(rand3 * 150 + 100); b = Math.floor(rand3 * 100); // Orange
              } else {
                r = 255; g = Math.floor(rand3 * 100 + 100); b = Math.floor(rand3 * 180 + 75); // Pink
              }
            } else {
              r = g = b = 0;
            }
          } else if (colorScheme === 'ocean') {
            if (isOn) {
              const depth = rand2;
              r = Math.floor(depth * 100); // 0-100
              g = Math.floor(depth * 200 + 55); // 55-255
              b = Math.floor(depth * 100 + 155); // 155-255
            } else {
              r = g = b = 0;
            }
          } else if (colorScheme === 'matrix') {
            if (isOn) {
              const brightness = Math.floor(rand2 * 200 + 55); // 55-255
              r = 0;
              g = brightness;
              b = Math.floor(brightness * 0.3); // Slight blue tint
            } else {
              r = g = b = 0;
            }
          } else if (colorScheme === 'vaporwave') {
            if (isOn) {
              const choice = rand2 < 0.5;
              if (choice) {
                r = 255; g = Math.floor(rand3 * 100 + 100); b = 255; // Pink
              } else {
                r = Math.floor(rand3 * 100); g = Math.floor(rand3 * 200 + 55); b = 255; // Cyan
              }
            } else {
              r = g = b = 0;
            }
          } else if (colorScheme === 'synthwave') {
            if (isOn) {
              const choice = Math.floor(rand2 * 3);
              if (choice === 0) {
                r = Math.floor(rand3 * 100 + 155); g = 0; b = 255; // Purple
              } else if (choice === 1) {
                r = 255; g = Math.floor(rand3 * 100); b = Math.floor(rand3 * 180 + 75); // Pink
              } else {
                r = 0; g = Math.floor(rand3 * 200 + 55); b = 255; // Cyan
              }
            } else {
              r = g = b = 0;
            }
          } else {
            r = g = b = 0;
          }

          data[i] = r;
          data[i + 1] = g;
          data[i + 2] = b;
          data[i + 3] = 255;
        }
      }

      stripCtx.putImageData(imageData, 0, 0);
      return stripCanvas;
    }

    // HSL to RGB conversion for rainbow mode
    function hslToRgb(h, s, l) {
      h = h / 360;
      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      const p = 2 * l - q;

      const hueToRgb = (p, q, t) => {
        if (t < 0) t += 1;
        if (t > 1) t -= 1;
        if (t < 1/6) return p + (q - p) * 6 * t;
        if (t < 1/2) return q;
        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
        return p;
      };

      return [
        Math.floor(hueToRgb(p, q, h + 1/3) * 255),
        Math.floor(hueToRgb(p, q, h) * 255),
        Math.floor(hueToRgb(p, q, h - 1/3) * 255)
      ];
    }

    // Generate Autostereogram
    function generateAutostereogram() {
      if (state.layers.length === 0) {
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, previewCanvas.width, previewCanvas.height);
        return;
      }
    
      const width  = state.settings.outputWidth;
      const height = state.settings.outputHeight;
      const stripW = state.settings.stripWidth;
      const MIN_SEP = 8; // donâ€™t let separation collapse; tweak 8â€“12 if needed
    
      // Clamp disparity so separation âˆˆ [MIN_SEP, stripW]
      const rawMaxDisp = Math.floor(stripW * state.settings.depthScale);
      const maxDisp    = Math.min(rawMaxDisp, stripW - MIN_SEP);
    
      // Depth map (0..255, where brighter = nearer)
      const depthMap = generateDepthMap();
    
      // Base pattern strip (width = stripW, tiled across each row)
      const patternStrip = generatePatternStrip(
        stripW,
        height,
        state.settings.patternDensity,
        state.settings.colorScheme
      );
      const stripData = patternStrip.getContext('2d').getImageData(0, 0, stripW, height);
    
      // Output
      const outputData = ctx.createImageData(width, height);
      const out = outputData.data;
    
      // Small union-find helper with path compression
      function findRoot(parent, i) {
        while (parent[i] !== i) {
          parent[i] = parent[parent[i]];
          i = parent[i];
        }
        return i;
      }
    
      for (let y = 0; y < height; y++) {
        const row = y * width;
        const parent = new Int32Array(width);
        for (let x = 0; x < width; x++) parent[x] = x;
    
        // 1) Link pixel pairs for this scanline
        for (let x = 0; x < width; x++) {
          const z = depthMap[row + x] / 255;                // 0..1
          const disp = Math.round(z * maxDisp);
          const sep  = Math.max(MIN_SEP, stripW - disp);    // safe separation
    
          // centered pairing around x
          const left  = x - Math.floor(sep / 2);
          const right = left + sep;
    
          if (left >= 0 && right < width) {
            // Prefer the nearer surface at this pair position
            const dl = depthMap[row + left];
            const dr = depthMap[row + right];
    
            let L = findRoot(parent, left);
            let R = findRoot(parent, right);
            if (L !== R) {
              if (dl >= dr) parent[R] = L; else parent[L] = R;
            }
          }
        }
    
        // 2) Paint: one color per set, sampled by the set rootâ€™s phase
        const colorByRoot = new Map();
        for (let x = 0; x < width; x++) {
          const root = findRoot(parent, x);
          let color = colorByRoot.get(root);
          if (!color) {
            const stripX = root % stripW;                   // IMPORTANT: use root, not x
            const si = (y * stripW + stripX) * 4;
            color = [
              stripData.data[si],
              stripData.data[si + 1],
              stripData.data[si + 2],
              255
            ];
            colorByRoot.set(root, color);
          }
    
          const oi = (row + x) * 4;
          out[oi]     = color[0];
          out[oi + 1] = color[1];
          out[oi + 2] = color[2];
          out[oi + 3] = 255;
        }
      }
    
      ctx.putImageData(outputData, 0, 0);
    }


    // Initialize
    generateAutostereogram();
  </script>
</body>
</html>
